//
//  SyncModels.swift
//  TheArabianCenter
//
//  Created by Ahmed Henawey on 2/25/17.
//  Copyright (c) 2017 Ahmed Henawey. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so you can apply
//  clean architecture to your iOS and Mac projects, see http://clean-swift.com
//

import UIKit
import ObjectMapper
import CoreLocation

struct Sync {
    
    struct Save {
        
        /// Save Request, it conform Mappable Protocal to Make ObjectMapper able to serialize the object to JSON and vice versa
        struct Request : Mappable,Hashable{
            var title:String
            var description:String
            var imageLocation:String?
            var lat:Double?
            var long:Double?
            
            init(title:String,
                 description:String,
                 imageLocation:String? = nil,
                 location:CLLocation? = nil) {
                self.title = title
                self.description = description
                self.imageLocation = imageLocation
                lat = location?.coordinate.latitude
                long = location?.coordinate.longitude
            }
            
            init?(map: Map) {
                guard let title = map.JSON["title"] as? String,
                    let description = map.JSON["description"] as? String,
                    let imageLocation = map.JSON["imageLocation"] as? String
                    else{
                        return nil
                }
                self.title = title
                self.description = description
                self.imageLocation = imageLocation
            }
            
            mutating func mapping(map: Map) {
                title <- map["title"]
                description <- map["description"]
                imageLocation <- map["imageLocation"]
                lat <- map["location.lat"]
                long <- map["location.long"]
            }
            
            var hashValue: Int{
                get{
                    return "\(title),\(description),\(lat),\(long)".hashValue   
                }
            }
            
            public static func ==(lhs: Sync.Save.Request, rhs: Sync.Save.Request) -> Bool{
                return lhs.hashValue == rhs.hashValue
            }
        }
    }
    
    struct Retrieve {
        struct Request{
            var id :String
            
            init(id :String) {
                self.id = id
            }
        }
    }
    
    /// Retrieve Response, it conform Mappable Protocal to Make ObjectMapper able to serialize the object to JSON and vice versa
    struct Response: Mappable{
        var id :String
        var title:String
        var description:String
        var imageLocation:String
        
        init(id :String,
             title:String,
             description:String,
             imageLocation:String) {
            self.id = id
            self.title = title
            self.description = description
            self.imageLocation = imageLocation
        }
        
        init?(map: Map) {
            guard let id = map.JSON["id"] as? String,
                let title = map.JSON["title"] as? String,
                let description = map.JSON["description"] as? String,
                let imageLocation = map.JSON["imageLocation"] as? String
                else{
                    return nil
            }
            self.id = id
            self.title = title
            self.description = description
            self.imageLocation = imageLocation
        }
        
        mutating func mapping(map: Map) {
            id <- map["id"]
            title <- map["title"]
            description <- map["description"]
            imageLocation <- map["imageLocation"]
        }
    }
    
    struct ViewModel
    {
        var id :String
        var title:String
        var description:String
        var imageLocation:String
    }
    enum Error:Swift.Error {
        case unknownError
        case configurationMissing
        case invalidData
        case invalidResponse
        case failure(error:Swift.Error)
        
        var localizedDescription: String{
            switch self {
            case .unknownError:
                return NSLocalizedString("unknownError", comment: "")
            case .configurationMissing:
                return NSLocalizedString("configurationMissing", comment: "")
            case .invalidData:
                return NSLocalizedString("InvalidData", comment: "")
            case .invalidResponse:
                return NSLocalizedString("invalidResponse", comment: "")
                
            case let .failure(error):
                return error.localizedDescription
            }
        }
    }
}
